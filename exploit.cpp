using namespace std;

#include <cmath>
#include <iostream>
#include <ctime>
#include <string>
#include <fstream>



// Assume a Diffie-Hellman Key exchange for any real world use
// Based on https://www.geeksforgeeks.org/implementation-diffie-hellman-algorithm/


// function to calculate key by getting the value of G ^ secret mod P
long long int calculate_key(long long int G, long long int secret,
                    long long int P)
{
    if (secret == 1)
        return G;

    else
        return (((long long int)pow(G, secret)) % P);
}

int main(int argc, char *argv[]){
    
    string line;
    ifstream myfile ("public_information.txt");
    long long int prime_number_P = 0, prime_number_G = 0, public_key = 0, shared_private_key = 0;
    string encypted_secret_message;

    // read public information from file
    if (myfile.is_open())
    {
        while (getline (myfile,line))
        {
            if(!prime_number_P){
                prime_number_P = stoll (line);
                continue;
            }

            if(!prime_number_G){
                prime_number_G = stoll (line);
                continue;
            }

            if(!public_key){
                public_key = stoll (line);
                continue;
            }

            if(encypted_secret_message.empty()){
                encypted_secret_message = line;
                continue;
            }
        }
        myfile.close();
    }
    else 
        cout << "Unable to open file"; 
    
    // Since the malicious actor knows that the private key is within 0 to (prime_number_P -1)
    // Guess the private key since although it is random, it can be guessed with ease.
    for(long long int private_key_guess = 0; private_key_guess < (prime_number_P-1); private_key_guess++){

        // if private key guessed computes the same public key, 
        // then the shared private key can be calculated
        if(calculate_key(prime_number_G, private_key_guess, prime_number_P) == public_key){
            shared_private_key = calculate_key(public_key, private_key_guess, prime_number_P);
            break;
        }
    }

    for(char& letter : encypted_secret_message){
        // decrypt the message by doing the reverse
        // of the encryption process.
        letter -= shared_private_key;
    }

    printf("Found shared private key: %lld\ndecrypted message is: %s\n", shared_private_key,encypted_secret_message.c_str());

    return 0;
}
